/*
 *      file: vcom.cpp
 *
 *      Copyright 2012-2014 Cirilo Bernardo (cjh.bernardo@gmail.com)
 *
 *      This program is free software: you can redistribute it and/or modify
 *      it under the terms of the GNU General Public License as published by
 *      the Free Software Foundation, either version 3 of the License, or
 *      (at your option) any later version.
 *
 *      This program is distributed in the hope that it will be useful,
 *      but WITHOUT ANY WARRANTY; without even the implied warranty of
 *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *      GNU General Public License for more details.
 *
 *      You should have received a copy of the GNU General Public License
 *      along with this program.  If not, see <http://www.gnu.org/licenses/>
 *
 */

#include <iostream>
#include <fstream>
#include <iomanip>

#include <vdefs.h>
#include <vcom.h>
#include <vrmlmat.h>

using namespace std;

#define MAX_TABS (6)

namespace KC3D
{

// Create the VRML header and ancillary comments
int SetupVRML( std::string aFilename, std::ofstream& aOutputStream )
{
    if( aFilename.empty() )
    {
        ERRBLURB;
        cerr << "empty filename\n";
        return -1;
    }

    if( aOutputStream.is_open() )
        aOutputStream.close();

    aOutputStream.open( aFilename.c_str() );

    if( !aOutputStream.good() )
    {
        ERRBLURB;
        cerr << "could not open file '" << aFilename << "'\n";
        return -1;
    }

    aOutputStream << "#VRML V2.0 utf8\n";
    aOutputStream << "#File: " << aFilename << "\n";
    aOutputStream << "#License: The contents of this file were generated by software;\n";
    aOutputStream << "#    the user is free to use, modify, and distribute this file\n";
    aOutputStream << "#    without restrictions.\n\n";

    if( !aOutputStream.good() )
    {
        ERRBLURB;
        cerr << "error writing to file '" << aFilename << "'\n";
        aOutputStream.close();
        return -1;
    }

    return 0;
}


// Set up a VRML Transform block
int SetupXForm( std::string aBlockName, std::ofstream& aVRMLFile, int aTabDepth )
{
    if( aBlockName.empty() )
    {
        ERRBLURB;
        cerr << "empty VRML Transform name\n";
        return -1;
    }

    if( !aVRMLFile.is_open() )
    {
        ERRBLURB;
        cerr << "no open file\n";
        return -1;
    }

    if( !aVRMLFile.good() )
    {
        ERRBLURB;
        cerr << "bad stream for VRML Transform '" << aBlockName << "'\n";
        return -1;
    }

    if( aTabDepth < 0 )
        aTabDepth = 0;

    if( aTabDepth > MAX_TABS )
        aTabDepth = MAX_TABS;

    string fmt( aTabDepth * 4, ' ' );

    aVRMLFile << fmt << "DEF " << aBlockName << " Transform {\n";
    aVRMLFile << fmt << "    children [\n";

    if( !aVRMLFile.good() )
    {
        ERRBLURB;
        cerr << "error writing to file\n";
        return -1;
    }

    return 0;
}


// Close a VRML Transform block
int CloseXForm( std::ofstream& aVRMLFile, int aTabDepth)
{
    if( !aVRMLFile.good() )
    {
        ERRBLURB;
        cerr << "bad stream for VRML Transform\n";
        return -1;
    }

    if( !aVRMLFile.is_open() )
    {
        ERRBLURB;
        cerr << "no open file\n";
        return -1;
    }

    if( aTabDepth < 0 )
        aTabDepth = 0;

    if( aTabDepth > MAX_TABS )
        aTabDepth = MAX_TABS;

    string fmt( aTabDepth * 4, ' ' );

    // close Children
    aVRMLFile << fmt << "    ]\n";
    // close Transform
    aVRMLFile << fmt << "}\n\n";

    if( !aVRMLFile.good() )
    {
        ERRBLURB;
        cerr << "error writing to file\n";
        return -1;
    }

    return 0;
}


// Set up a VRML Shape block (includes appearance and geometry)
int SetupShape( VRMLMAT& aMaterial, bool reuseMaterial,
        std::ofstream& aVRMLFile, int aTabDepth )
{
    if( !aVRMLFile.good() )
    {
        ERRBLURB;
        cerr << "bad stream for VRML Shape\n";
        return -1;
    }

    if( !aVRMLFile.is_open() )
    {
        ERRBLURB;
        cerr << "no open file\n";
        return -1;
    }

    if( aTabDepth < 0 )
        aTabDepth = 0;

    if( aTabDepth > MAX_TABS )
        aTabDepth = MAX_TABS;

    string fmt( aTabDepth * 4, ' ' );
    aVRMLFile << fmt << "Shape {\n";
    aVRMLFile << fmt << "    appearance Appearance {\n";

    if( !aMaterial.GetName().empty() )
    {
        if( !reuseMaterial )
        {
            aMaterial.WriteMaterial( aVRMLFile, aTabDepth + 2 );
        }
        else
        {
            aVRMLFile << fmt << "        material USE " << aMaterial.GetName() << "\n";
        }
    }
    else
    {
        ERRBLURB;
        cerr << "invalid material appearance; using default bright red\n";
        aVRMLFile << fmt << "        material Material {\n";
        aVRMLFile << fmt << "            diffuseColor 1 0 0\n";
        aVRMLFile << fmt << "            emissiveColor 1 0 0\n";
        aVRMLFile << fmt << "            specularColor 1 0 0\n";
        aVRMLFile << fmt << "            ambientIntensity 1\n";
        aVRMLFile << fmt << "            transparency 0\n";
        aVRMLFile << fmt << "            shininess 0.5\n";
        aVRMLFile << fmt << "        }\n";
    }

    aVRMLFile << fmt << "    }\n";
    aVRMLFile << fmt << "    geometry IndexedFaceSet {\n";

    if( !aVRMLFile.good() )
    {
        ERRBLURB;
        cerr << "error writing to file\n";
        return -1;
    }

    return 0;
}


// Close a VRML Shape and Geometry block
int CloseShape( std::ofstream& aVRMLFile, int aTabDepth )
{
    if( !aVRMLFile.good() )
    {
        ERRBLURB;
        cerr << "bad stream for VRML Shape/Geometry\n";
        return -1;
    }

    if( !aVRMLFile.is_open() )
    {
        ERRBLURB;
        cerr << "no open file\n";
        return -1;
    }

    if( aTabDepth < 0 )
        aTabDepth = 0;

    if( aTabDepth > MAX_TABS )
        aTabDepth = MAX_TABS;

    string fmt( aTabDepth * 4, ' ' );

    aVRMLFile << fmt << "    }\n";
    aVRMLFile << fmt << "}\n";

    if( !aVRMLFile.good() )
    {
        ERRBLURB;
        cerr << "error writing to file\n";
        return -1;
    }

    return 0;
}


// Write a VRML coordinate block
int WriteCoord( double* x, double* y, double* z, int nPoints,
                std::ofstream& aVRMLFile, int aTabDepth )
{
    if( !aVRMLFile.good() )
    {
        ERRBLURB;
        cerr << "bad stream for VRML Coord\n";
        return -1;
    }

    if( !aVRMLFile.is_open() )
    {
        ERRBLURB;
        cerr << "no open file\n";
        return -1;
    }

    if( nPoints < 3 )
    {
        ERRBLURB;
        cerr << "invalid number of coordinate points (" << nPoints << "); must be >= 3\n";
        return -1;
    }

    if( aTabDepth < 0 )
        aTabDepth = 0;

    if( aTabDepth > MAX_TABS )
        aTabDepth = MAX_TABS;

    string fmt( aTabDepth * 4, ' ' );

    aVRMLFile << fmt << "coord Coordinate { point [\n";
    aVRMLFile << fmt << "   ";
    int i;
    double tx, ty, tz;

    for( i = 0; i < (nPoints - 1); ++i )
    {
        tx  = x[i];
        ty  = y[i];
        tz  = z[i];

        if( (tx < 1e-9) && (tx > -1e-9) )
            tx = 0;

        if( (ty < 1e-9) && (ty > -1e-9) )
            ty = 0;

        if( (tz < 1e-9) && (tz > -1e-9) )
            tz = 0;

        aVRMLFile << setprecision( 8 ) << " " << tx << " " << ty << " " << tz << ",";

        if( !( (i + 1) % 6 ) )
            aVRMLFile << "\n" << fmt << "   ";
    }

    tx  = x[i];
    ty  = y[i];
    tz  = z[i];

    if( (tx < 1e-9) && (tx > -1e-9) )
        tx = 0;

    if( (ty < 1e-9) && (ty > -1e-9) )
        ty = 0;

    if( (tz < 1e-9) && (tz > -1e-9) )
        tz = 0;

    aVRMLFile << setprecision( 8 ) << " " << tx << " " << ty << " " << tz << " ]\n";
    aVRMLFile << fmt << "}\n";

    if( !aVRMLFile.good() )
    {
        ERRBLURB;
        cerr << "error writing to file\n";
        return -1;
    }

    return 0;
}


// Set up a VRML coordIndex block
int SetupCoordIndex( std::ofstream& aVRMLFile, int aTabDepth )
{
    if( !aVRMLFile.good() )
    {
        ERRBLURB;
        cerr << "bad stream for VRML CoordIndex\n";
        return -1;
    }

    if( !aVRMLFile.is_open() )
    {
        ERRBLURB;
        cerr << "no open file\n";
        return -1;
    }

    if( aTabDepth < 0 )
        aTabDepth = 0;

    if( aTabDepth > MAX_TABS )
        aTabDepth = MAX_TABS;

    string fmt( aTabDepth * 4, ' ' );

    aVRMLFile << fmt << "coordIndex [\n";

    if( !aVRMLFile.good() )
    {
        ERRBLURB;
        cerr << "error writing to file\n";
        return -1;
    }

    return 0;
}


// Close a VRML coordIndex block
int CloseCoordIndex( std::ofstream& aVRMLFile, int aTabDepth )
{
    if( !aVRMLFile.good() )
    {
        ERRBLURB;
        cerr << "bad stream for VRML CoordIndex\n";
        return -1;
    }

    if( !aVRMLFile.is_open() )
    {
        ERRBLURB;
        cerr << "no open file\n";
        return -1;
    }

    if( aTabDepth < 0 )
        aTabDepth = 0;

    if( aTabDepth > MAX_TABS )
        aTabDepth = MAX_TABS;

    string fmt( aTabDepth * 4, ' ' );

    aVRMLFile << fmt << "]\n";

    if( !aVRMLFile.good() )
    {
        ERRBLURB;
        cerr << "error writing to file\n";
        return -1;
    }

    return 0;
}

}    // namespace KC3D
